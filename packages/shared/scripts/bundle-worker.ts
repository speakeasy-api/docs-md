#!/usr/bin/env tsx
/**
 * Bundle worker code at build time
 *
 * Compiles run-worker.ts into a standalone JavaScript module and embeds it
 * as a string constant. This prevents webpack from processing it as a worker.
 */

import { build } from "esbuild";
import { writeFileSync, mkdirSync } from "fs";
import { join } from "path";

const WORKER_SOURCE = "src/codeRuntime/run-worker.ts";
const OUTPUT_DIR = "dist/codeRuntime";
const OUTPUT_FILE = "worker-code.generated.js";

async function bundleWorker(): Promise<void> {
  try {
    console.log("Bundling worker code...");

    // Bundle the worker using esbuild
    const result = await build({
      entryPoints: [WORKER_SOURCE],
      bundle: true,
      format: "esm",
      target: "es2020",
      platform: "browser",
      write: false,
      minify: process.env.NODE_ENV === "production",
      logLevel: "silent", // We'll handle logging ourselves
    });

    const outputFile = result.outputFiles?.[0];
    if (!outputFile) {
      throw new Error("Build produced no output files");
    }

    const workerCode = new TextDecoder().decode(outputFile.contents);

    // Ensure output directory exists
    mkdirSync(OUTPUT_DIR, { recursive: true });

    // Generate JavaScript module with embedded worker code
    // Using JS instead of TS since it's just a string export
    const generatedContent = `// Auto-generated by scripts/bundle-worker.ts
// DO NOT EDIT - changes will be overwritten on next build

/**
 * Compiled worker code embedded as a string.
 * Used to create a Blob URL at runtime, bypassing webpack's worker processing.
 */
export const WORKER_CODE = ${JSON.stringify(workerCode)};
`;

    const outputPath = join(OUTPUT_DIR, OUTPUT_FILE);
    writeFileSync(outputPath, generatedContent, "utf-8");

    const sizeKB = (workerCode.length / 1024).toFixed(2);
    console.log(`Worker bundled successfully (${sizeKB} KB)`);
    console.log(`   Output: ${outputPath}`);

  } catch (error) {
    console.error("Failed to bundle worker:");
    console.error(error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

void bundleWorker();